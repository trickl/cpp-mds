13c13
< #include <boost/property_map.hpp>
---
> #include <boost/property_map/property_map.hpp>
18c18,19
< #include <patch/graph/planar_canonical_ordering.hpp>
---
> #include <boost/graph/make_biconnected_planar.hpp>
> #include <boost/graph/make_maximal_planar.hpp>
24c25
< cpmds::cpmds() : _flatten_item(0), _graph_iteration(0), _focus(50), _flattened_curvature_sum(0)
---
> cpmds::cpmds() : _flatten_item(0), _graph_iteration(0), _focus(80), _flattened_curvature_sum(0)
52c53
<    vector<unsigned int> perimeter;
---
>    list<unsigned int> perimeter;
58c59
<       vector<unsigned int>::const_iterator neighbour_itr = perimeter.begin();
---
>       list<unsigned int>::const_iterator neighbour_itr = perimeter.begin();
82a84
>       i.is_located = false;
133a136,138
>          i_a.curvature -= 2 * subtended_half_angle(i_a.radius, i_b.radius);
>          i_b.curvature -= 2 * subtended_half_angle(i_b.radius, i_a.radius);
> 
219,220c224,225
<       adjustments[id].curvature_delta -= subtended_angle(r, r_c, r_a)
<                                        + subtended_angle(r, r_c, r_b);
---
>       adjustments[id].curvature_delta -= subtended_angle(r, r_a, r_c)
>                                        + subtended_angle(r, r_b, r_c);
242a248,259
>    else
>    {
>       adjustments[id].curvature_delta -= subtended_half_angle(r, r_a)
>                                        + subtended_half_angle(r, r_b);
> 
>       adjustments[a_id].curvature_delta -= subtended_half_angle(r_a, r)
>                                          - subtended_half_angle(r_a, r_b);
> 
>       adjustments[b_id].curvature_delta -= subtended_half_angle(r_b, r)
>                                          - subtended_half_angle(r_b, r_a);
> 
>    }
280c297
<    vector<unsigned int> perimeter;
---
>    list<unsigned int> perimeter;
284c301
<    for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>    for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
286c303
<       vector<unsigned int>::const_iterator next_itr = itr;
---
>       list<unsigned int>::const_iterator next_itr = itr;
319c336
<    vector<unsigned int> perimeter;
---
>    list<unsigned int> perimeter;
323,328c340
<    vector<unsigned int>::const_iterator perimeter_edge_end_itr = perimeter.begin();
<    if (!perimeter.empty() && perimeter.front() == 0) 
<    {
<       perimeter_edge_end_itr = perimeter.erase(perimeter.begin());
<       ++perimeter_edge_end_itr;
<    }
---
>    list<unsigned int>::const_iterator perimeter_edge_end_itr = perimeter.begin();
330c342
<    if (perimeter.size() > 1)
---
>    if (!perimeter.empty())
341c353
<       for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>       for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
343,349c355,364
<          item_adjustment ia;
<          ia.id = *itr;
<          ia.curvature_delta = 0;
<          ia.weight_sum_delta = 0;
<          ia.distance_weight_sum_delta = 0;
<          ia.connectivity_delta = 0;
<          adjustments[*itr] = ia;
---
>          if (*itr != 0)
>          {
>             item_adjustment ia;
>             ia.id = *itr;
>             ia.curvature_delta = 0;
>             ia.weight_sum_delta = 0;
>             ia.distance_weight_sum_delta = 0;
>             ia.connectivity_delta = 0;
>             adjustments[*itr] = ia;
>          }
352c367
<       for (vector<unsigned int>::const_iterator end = perimeter.end(); perimeter_edge_end_itr != end; ++perimeter_edge_end_itr)
---
>       for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
354,357c369,372
<          vector<unsigned int>::const_iterator perimeter_edge_start_itr = perimeter_edge_end_itr;
<          if (perimeter_edge_start_itr == perimeter.begin())
<             perimeter_edge_start_itr = perimeter.end();
<          --perimeter_edge_start_itr;
---
>          list<unsigned int>::const_iterator prev_itr = itr;
>          if (prev_itr == perimeter.begin())
>             prev_itr = perimeter.end();
>          --prev_itr;
359,362c374,400
<          item_pk::iterator a_itm_itr = itm_pk.find(*perimeter_edge_start_itr);
<          item_pk::iterator b_itm_itr = itm_pk.find(*perimeter_edge_end_itr);
<          double r_a = a_itm_itr->radius;
<          double r_b = b_itm_itr->radius;
---
>          if (*itr != 0)
>          {
>             item_pk::iterator a_itm_itr = itm_pk.find(*itr);
>             double r_a = a_itm_itr->radius;
> 
>             if (*prev_itr != 0)
>             {
>                item_pk::iterator b_itm_itr = itm_pk.find(*prev_itr);
>                double r_b = b_itm_itr->radius;
> 
>                central_curvature -= subtended_angle(r, r_a, r_b); 
>                adjustments[*itr].curvature_delta -= subtended_angle(r_a, r, r_b)
>                                                   - subtended_angle(r_a, r_old, r_b);
>                adjustments[*prev_itr].curvature_delta -= subtended_angle(r_b, r, r_a)
>                                                        - subtended_angle(r_b, r_old, r_a);
>             }
>             else
>             {
>                central_curvature -= subtended_half_angle(r, r_a); 
>                adjustments[*itr].curvature_delta -= subtended_half_angle(r_a, r)
>                                                   - subtended_half_angle(r_a, r_old);
>             }
>          }
>          else if (*prev_itr != 0)
>          {
>             item_pk::iterator b_itm_itr = itm_pk.find(*prev_itr);
>             double r_b = b_itm_itr->radius;
364,368c402,405
<          central_curvature -= subtended_angle(r, r_a, r_b); 
<          adjustments[*perimeter_edge_start_itr].curvature_delta -= subtended_angle(r_a, r, r_b)
<                                                                  - subtended_angle(r_a, r_old, r_b);
<          adjustments[*perimeter_edge_end_itr].curvature_delta -= subtended_angle(r_b, r, r_a)
<                                                                - subtended_angle(r_b, r_old, r_a);
---
>             central_curvature -= subtended_half_angle(r, r_b); 
>             adjustments[*prev_itr].curvature_delta -= subtended_half_angle(r_b, r)
>                                                     - subtended_half_angle(r_b, r_old);
>          }
378c415
<       for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>       for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
380,383c417,423
<          itm_itr = itm_pk.find(*itr);
<          i = *itm_itr;
<          i.curvature += adjustments[*itr].curvature_delta;
<          itm_pk.replace(itm_itr, i);
---
>          if (*itr != 0)
>          {
>             itm_itr = itm_pk.find(*itr);
>             i = *itm_itr;
>             i.curvature += adjustments[*itr].curvature_delta;
>             itm_pk.replace(itm_itr, i);
>          }
388c428
< void cpmds::get_decrease_curvature_transform(unsigned int id, vector<unsigned int>& fan_trfm_perimeter)
---
> void cpmds::get_increase_curvature_transform(unsigned int id, list<unsigned int>& fan_trfm_perimeter) const
391c431,454
<    item_pk& itm_pk = item_table.get<item_pk_type>();
---
>    const item_pk& itm_pk = item_table.get<item_pk_type>();
>    double lowest_stress_delta = numeric_limits<double>::max();
> 
>    list<unsigned int> perimeter;
>    get_perimeter(id, perimeter);
> 
>    // Push out the curvature, find the least similar adjacent node
>    for (list<unsigned int>::const_iterator pivot_itr = perimeter.begin(), end = perimeter.end(); pivot_itr != end; ++pivot_itr)
>    {
>       // Seek to disconnect [id] from [pivot]
>       bool potential_fan_trfm_clockwise = true;
>       do
>       {
>          list<unsigned int>::const_iterator other_itr = pivot_itr;
>          if (potential_fan_trfm_clockwise) 
>          {
>             if (other_itr == perimeter.begin()) other_itr = perimeter.end();
>             --other_itr;
>          }
>          else
>          {
>             ++other_itr;
>             if (other_itr == perimeter.end()) other_itr = perimeter.begin();
>          }
393c456,577
<    // Store a list of all processed faces in a vector
---
>          // The curvature of [pivot] and [other] will be significantly changed
>          if (_flattened_items.find(*other_itr) == _flattened_items.end() &&
>              _flattened_items.find(*pivot_itr) == _flattened_items.end())
>          {
> 
>             list<unsigned int> pivot_perimeter;
>             get_perimeter(*pivot_itr, pivot_perimeter);
>             if (potential_fan_trfm_clockwise) reverse(pivot_perimeter.begin(), pivot_perimeter.end());
> 
>             list<unsigned int>::iterator pivot_id_itr = find(pivot_perimeter.begin(), pivot_perimeter.end(), id);
>             rotate(pivot_perimeter.begin(), pivot_id_itr, pivot_perimeter.end());
> 
>             list<unsigned int> potential_fan_trfm_perimeter;
>             potential_fan_trfm_perimeter.push_back(*pivot_itr);
>             if (potential_fan_trfm_clockwise)
>             {  
>                potential_fan_trfm_perimeter.push_back(id);
>                potential_fan_trfm_perimeter.push_back(*other_itr);
>             }
>             else
>             {
>                potential_fan_trfm_perimeter.push_back(*other_itr);
>                potential_fan_trfm_perimeter.push_back(id);
>             }
> 
>             adjacency_face f_tmp;
>             for (list<unsigned int>::iterator pivot_last_itr = ++pivot_perimeter.begin(), pivot_other_itr = --pivot_perimeter.end(); pivot_last_itr != pivot_other_itr && potential_fan_trfm_perimeter.size() < 5; ++pivot_last_itr)
>             {
>                // Ensure that the joined neighbours of [id] are not already connected (separating triangle)
>                // and that they are not both on the flattened boundary
>                if (find_adjacency_face(*other_itr, *pivot_last_itr, f_tmp) != adf_pk.end()
>                    || (_flattened_boundary_items.find(*other_itr) != _flattened_boundary_items.end() 
>                        && _flattened_boundary_items.find(*pivot_last_itr) != _flattened_boundary_items.end()))
>                {
>                   break;
>                }
>             
>                if (potential_fan_trfm_clockwise)
>                {
>                   potential_fan_trfm_perimeter.insert(++potential_fan_trfm_perimeter.begin(), *pivot_last_itr);
>                }
>                else
>                {
>                   potential_fan_trfm_perimeter.push_back(*pivot_last_itr);
>                }
> 
>                if (_flattened_items.find(*pivot_last_itr) == _flattened_items.end())
>                {
>                   // TODO Tidy this up if possible
>                   if (potential_fan_trfm_clockwise)
>                      rotate(potential_fan_trfm_perimeter.begin(),
>                             --potential_fan_trfm_perimeter.end(),
>                             potential_fan_trfm_perimeter.end());
>                   else
>                      rotate(potential_fan_trfm_perimeter.begin(),
>                             ++potential_fan_trfm_perimeter.begin(),
>                             potential_fan_trfm_perimeter.end());
> 
>                   bool can_adjust = true;
>                   map<unsigned int, item_adjustment> adjustments;
>                   fan_transform(potential_fan_trfm_perimeter, adjustments);
>                   if (potential_fan_trfm_perimeter.size() > 4)
>                   {
>                      // There will be a small adjustment to the flattened item, check to see if it is acceptable
>                      list<unsigned int>::const_iterator minor_adjust_itr = pivot_last_itr;
>                      --minor_adjust_itr;
> 
>                      if (_flattened_items.find(*minor_adjust_itr) != _flattened_items.end())
>                      {
> 
>                         if (!is_beneficial_adjustment(*minor_adjust_itr, adjustments[*minor_adjust_itr].curvature_delta))
>                         {
>                            can_adjust = false;
>                         }
>                      }
>                   }
> 
>                   if (can_adjust)
>                   {
>                      double stress_delta = 0;
>                      for (map<unsigned int, item_adjustment>::const_iterator itr = adjustments.begin(), end = adjustments.end(); itr != end; ++itr)
>                      {
>                         item_pk::const_iterator adj_itm_itr = itm_pk.find(itr->first);
>                         stress_delta += (itr->second.distance_weight_sum_delta - itr->second.weight_sum_delta * adj_itm_itr->distance_weight_sum / adj_itm_itr->weight_sum)
>                                         / (adj_itm_itr->weight_sum + itr->second.weight_sum_delta);
>                      }
> 
>                      if (stress_delta <= lowest_stress_delta)
>                      {
>                         lowest_stress_delta = stress_delta;
>                         //cout << "Lowest stress delta - " << lowest_stress_delta << endl;
>                         fan_trfm_perimeter.clear();
>                         copy(potential_fan_trfm_perimeter.begin(), potential_fan_trfm_perimeter.end(), back_inserter(fan_trfm_perimeter));
>                      }
>                   }
> 
>                   if (potential_fan_trfm_clockwise)
>                      rotate(potential_fan_trfm_perimeter.begin(),
>                             ++potential_fan_trfm_perimeter.begin(),
>                             potential_fan_trfm_perimeter.end());
>                   else
>                      rotate(potential_fan_trfm_perimeter.begin(),
>                             --potential_fan_trfm_perimeter.end(),
>                             potential_fan_trfm_perimeter.end());
> 
> 
>                }
>             }
>          }
> 
>          potential_fan_trfm_clockwise = !potential_fan_trfm_clockwise;
>       }
>       while (potential_fan_trfm_clockwise == false);
>    }
> }
> 
> void cpmds::get_decrease_curvature_transform(unsigned int id, list<unsigned int>& fan_trfm_perimeter) const
> {
>    const adjacency_face_pk& adf_pk = adjacency_face_table.get<adjacency_face_pk_type>();
>    const item_pk& itm_pk = item_table.get<item_pk_type>();
> 
>    // Store a list of all processed faces in a list
395c579
<    vector<unsigned int> candidate_faces;
---
>    list<unsigned int> candidate_faces;
400c584
<    vector<unsigned int> perimeter;
---
>    list<unsigned int> perimeter;
403c587,588
<    for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>    bool discovered_faces = false;
>    for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
405c590
<       vector<unsigned int>::const_iterator next_itr = itr;
---
>       list<unsigned int>::const_iterator next_itr = itr;
415a601
>          discovered_faces = true;
419,420c605,631
<    // Process each generation of faces until a non-boundary item or edge is found
<    if (!processed_faces.empty())
---
>    if (!discovered_faces)
>    {
>       // Handle the case where the two boundary neighbours are flattened exterior items
>       map<unsigned int, list<unsigned int>::iterator>::const_iterator boundary_itr = _flattened_boundary_items.find(id);
>       if (boundary_itr != _flattened_boundary_items.end())
>       {
>          list<unsigned int>::const_iterator itr = boundary_itr->second;
> 
>          list<unsigned int>::const_iterator prev_itr = itr;
>          if (prev_itr == _flattened_boundary.begin()) prev_itr = _flattened_boundary.end();
>          --prev_itr;
> 
>          list<unsigned int>::const_iterator next_itr = itr;
>          ++next_itr;
>          if (next_itr == _flattened_boundary.end()) next_itr = _flattened_boundary.begin();
> 
>          if (!is_interior_item(*prev_itr) && !is_interior_item(*next_itr))
>          {
>             // We can convert this item to an exterior item
>             fan_trfm_perimeter.push_back(0);
>             fan_trfm_perimeter.push_back(*next_itr);
>             fan_trfm_perimeter.push_back(id);
>             fan_trfm_perimeter.push_back(*prev_itr);
>          }
>       }
>    }
>    else
422c633,634
<       while (candidate_faces.empty())
---
>       // Process each generation of faces until a non-boundary item or edge is found
>       while (candidate_faces.empty() && discovered_faces)
424a637
>          discovered_faces = false;
436c649,650
<                if (find(_flattened_boundary.begin(), _flattened_boundary.end(), f_current.third_itm_id) == _flattened_boundary.end()
---
>                if (_flattened_boundary_items.find(f_current.third_itm_id) == _flattened_boundary_items.end()
>                    //&& is_interior_item(f_current.third_itm_id)
449a664
>                   discovered_faces = true;
456d670
<    }
458,483c672,692
<    // Find the path that if transformed produces the lowest stress
<    double lowest_stress_delta = numeric_limits<double>::max();
<    for (vector<unsigned int>::const_iterator itr = candidate_faces.begin(), end = candidate_faces.end(); itr != end; ++itr)
<    {
<       // Transform each path into a transform
<       vector<unsigned int> potential_fan_trfm_perimeter;
<       vector<unsigned int> potential_fan_trfm_clockwise;
<       unsigned int child_id = *itr;
< 
<       adjacency_face f_current = processed_faces[child_id];
<       potential_fan_trfm_perimeter.push_back(f_current.third_itm_id);
<       potential_fan_trfm_perimeter.push_back(f_current.first_itm_id);
<       potential_fan_trfm_clockwise.push_back(f_current.second_itm_id);
< 
<       // Build the transform perimeter from the face hierarchy
<       map<unsigned int, unsigned int>::const_iterator path_itr = child_parent_path_map.find(child_id);
<       while (path_itr != child_parent_path_map.end())
<       {
<          adjacency_face f_last = f_current;
<          child_id = path_itr->second;
<          f_current = processed_faces[child_id];
< 
<          if (f_current.third_itm_id == f_last.first_itm_id)
<             potential_fan_trfm_perimeter.push_back(f_current.first_itm_id);
<          else
<             potential_fan_trfm_clockwise.push_back(f_current.second_itm_id);
---
>       // Find the path that if transformed produces the lowest stress
>       double lowest_stress_delta = numeric_limits<double>::max();
>       for (list<unsigned int>::const_iterator itr = candidate_faces.begin(), end = candidate_faces.end(); itr != end; ++itr)
>       {
>          // Transform each path into a transform
>          list<unsigned int> potential_fan_trfm_perimeter;
>          list<unsigned int> potential_fan_trfm_clockwise;
>          unsigned int child_id = *itr;
> 
>          adjacency_face f_current = processed_faces[child_id];
>          potential_fan_trfm_perimeter.push_back(f_current.third_itm_id);
>          potential_fan_trfm_perimeter.push_back(f_current.first_itm_id);
>          potential_fan_trfm_clockwise.push_back(f_current.second_itm_id);
> 
>          // Build the transform perimeter from the face hierarchy
>          map<unsigned int, unsigned int>::const_iterator path_itr = child_parent_path_map.find(child_id);
>          while (path_itr != child_parent_path_map.end())
>          {
>             adjacency_face f_last = f_current;
>             child_id = path_itr->second;
>             f_current = processed_faces[child_id];
485,486c694,697
<          path_itr = child_parent_path_map.find(child_id);
<       }
---
>             if (f_current.third_itm_id == f_last.first_itm_id)
>                potential_fan_trfm_perimeter.push_back(f_current.first_itm_id);
>             else
>                potential_fan_trfm_clockwise.push_back(f_current.second_itm_id);
488,491c699,700
<       potential_fan_trfm_clockwise.push_back(id);
<       copy(potential_fan_trfm_clockwise.rbegin(),
<            potential_fan_trfm_clockwise.rend(),
<            back_inserter(potential_fan_trfm_perimeter));
---
>             path_itr = child_parent_path_map.find(child_id);
>          }
493,498c702,705
<       double stress_delta = 0;
<       if (candidate_faces.size() > 1)
<       {
<          // Find the best transform by calculating the induced stress
<          map<unsigned int, item_adjustment> adjustments;
<          fan_transform(potential_fan_trfm_perimeter, adjustments, false);
---
>          potential_fan_trfm_clockwise.push_back(id);
>          copy(potential_fan_trfm_clockwise.rbegin(),
>               potential_fan_trfm_clockwise.rend(),
>               back_inserter(potential_fan_trfm_perimeter));
500c707,708
<          for (map<unsigned int, item_adjustment>::const_iterator itr = adjustments.begin(), end = adjustments.end(); itr != end; ++itr)
---
>          double stress_delta = 0;
>          if (candidate_faces.size() > 1)
502,503c710,718
<             item_pk::const_iterator adj_itm_itr = itm_pk.find(itr->first);
<             stress_delta += (itr->second.distance_weight_sum_delta - itr->second.weight_sum_delta * adj_itm_itr->distance_weight_sum / adj_itm_itr->weight_sum) / (adj_itm_itr->weight_sum + itr->second.weight_sum_delta);
---
>             // Find the best transform by calculating the induced stress
>             map<unsigned int, item_adjustment> adjustments;
>             fan_transform(potential_fan_trfm_perimeter, adjustments);
> 
>             for (map<unsigned int, item_adjustment>::const_iterator itr = adjustments.begin(), end = adjustments.end(); itr != end; ++itr)
>             {
>                item_pk::const_iterator adj_itm_itr = itm_pk.find(itr->first);
>                stress_delta += (itr->second.distance_weight_sum_delta - itr->second.weight_sum_delta * adj_itm_itr->distance_weight_sum / adj_itm_itr->weight_sum) / (adj_itm_itr->weight_sum + itr->second.weight_sum_delta);
>             }
505d719
<       }
507,512c721,727
<       if (stress_delta <= lowest_stress_delta)
<       {
<          lowest_stress_delta = stress_delta;
<          cout << "Lowest stress delta - " << lowest_stress_delta << endl;
<          fan_trfm_perimeter.clear();
<          copy(potential_fan_trfm_perimeter.begin(), potential_fan_trfm_perimeter.end(), back_inserter(fan_trfm_perimeter));
---
>          if (stress_delta <= lowest_stress_delta)
>          {
>             lowest_stress_delta = stress_delta;
>             cout << "Lowest stress delta - " << lowest_stress_delta << endl;
>             fan_trfm_perimeter.clear();
>             copy(potential_fan_trfm_perimeter.begin(), potential_fan_trfm_perimeter.end(), back_inserter(fan_trfm_perimeter));
>          }
517c732
< void cpmds::get_perimeter(unsigned int id, vector<unsigned int>& perimeter, unsigned int start_id, unsigned int end_id) const
---
> void cpmds::get_perimeter(unsigned int id, list<unsigned int>& perimeter, unsigned int start_id, unsigned int end_id) const
572c787
<    vector<unsigned int> perimeter;
---
>    list<unsigned int> perimeter;
580c795
<       for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>       for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
604c819
<       for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>       for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
618c833
<       for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>       for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
620c835
<          vector<unsigned int>::const_iterator next_itr = itr;
---
>          list<unsigned int>::const_iterator next_itr = itr;
636a852,855
>             else
>             {
>                adjustments[*itr].curvature_delta      += subtended_half_angle(r_a, r);
>             }
642a862,868
>          else if (*next_itr != 0)
>          {
>             item_pk::iterator b_itm_itr = itm_pk.find(*next_itr);
>             double r_b = b_itm_itr->radius;
> 
>             adjustments[*next_itr].curvature_delta += subtended_half_angle(r_b, r);
>          }
647c873
<    if (!perimeter.empty() && perimeter.front() != 0)
---
>    if (!perimeter.empty())
649,650c875,876
<       // Ensure the boundary edge (item id = 0) is the second item in the list, so it is covered
<       rotate(perimeter.begin(), perimeter.end() - 1, perimeter.end());
---
>       // Ensure the boundary edge (item id = 0) is the second item in the list, so it is covered in the first pass
>       rotate(perimeter.begin(), --perimeter.end(), perimeter.end());
657c883
<          for (unsigned int i = 0; i < perimeter.size() - 1; ++i)
---
>          for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = --perimeter.end(); itr != end; ++itr)
659,661c885,887
<             unsigned int a_id = perimeter[i];
<             unsigned int b_id = perimeter[i + 1];
<             unsigned int c_id = (i + 2 != perimeter.size()) ? perimeter[i + 2] : perimeter[0];
---
>             unsigned int a_id = *itr;
>             unsigned int b_id = *boost::next(itr);
>             unsigned int c_id = (boost::next(boost::next(itr)) != perimeter.end()) ? *boost::next(boost::next(itr)): *perimeter.begin();
673a900,917
>                item_pk::iterator a_itm_itr = itm_pk.find(a_id);
>                item_pk::iterator c_itm_itr = itm_pk.find(c_id);
>                double r_a = a_itm_itr->radius;
>                double r_c = c_itm_itr->radius;
> 
>                // The final face does not create a new connection
>                if (perimeter.size() - triangulated_items.size() > 2)
>                {
>                   pair<double, double> distance_weight = get_weighted_measure(a_id, c_id, WEIGHTED_DISTANCE);
>                   adjustments[a_id].connectivity_delta += 1;
>                   adjustments[a_id].weight_sum_delta += distance_weight.first;
>                   adjustments[a_id].distance_weight_sum_delta += distance_weight.second * distance_weight.first;
> 
>                   adjustments[c_id].connectivity_delta += 1;
>                   adjustments[c_id].weight_sum_delta += distance_weight.first;
>                   adjustments[c_id].distance_weight_sum_delta += distance_weight.second * distance_weight.first;
>                }
> 
675c919
<                if (c_id != 0)
---
>                if (b_id != 0)
677d920
<                   item_pk::iterator a_itm_itr = itm_pk.find(a_id);
679,680d921
<                   item_pk::iterator c_itm_itr = itm_pk.find(c_id);
<                   double r_a = a_itm_itr->radius;
682d922
<                   double r_c = c_itm_itr->radius;
686,698c926,930
< 
<                   // The final face does not create a new connection
<                   if (perimeter.size() - triangulated_items.size() > 2)
<                   {
<                      pair<double, double> distance_weight = get_weighted_measure(a_id, c_id, WEIGHTED_DISTANCE);
<                      adjustments[a_id].connectivity_delta += 1;
<                      adjustments[a_id].weight_sum_delta += distance_weight.first;
<                      adjustments[a_id].distance_weight_sum_delta += distance_weight.second * distance_weight.first;
< 
<                      adjustments[c_id].connectivity_delta += 1;
<                      adjustments[c_id].weight_sum_delta += distance_weight.first;
<                      adjustments[c_id].distance_weight_sum_delta += distance_weight.second * distance_weight.first;
<                   }
---
>                }
>                else
>                {
>                   adjustments[a_itm_itr->id].curvature_delta -= subtended_half_angle(r_a, r_c);
>                   adjustments[c_itm_itr->id].curvature_delta -= subtended_half_angle(r_c, r_a);
701c933
<                ++i;
---
>                ++itr;
706c938
<          for (vector<unsigned int>::iterator itr = perimeter.begin(); itr != perimeter.end();)
---
>          for (list<unsigned int>::iterator itr = perimeter.begin(); itr != perimeter.end();)
714,727d945
<    else
<    {
<       // Create new faces for the new boundary
<       if (update && perimeter.size() > 2)
<       {
<          for (vector<unsigned int>::iterator itr = ++(++perimeter.begin()); itr != perimeter.end(); ++itr)
<          {
<             vector<unsigned int>::iterator prev_itr = itr;
<             --prev_itr;
< 
<             adf_pk.insert(make_face(*prev_itr, *itr, 0));
<          }
<       }
<    }
734a953
>       i.is_located = false;
753c972,977
< void cpmds::fan_transform(const vector<unsigned int> &perimeter, map<unsigned int, item_adjustment> &adjustments, bool update)
---
> void cpmds::fan_transform(const list<unsigned int> &perimeter, map<unsigned int, item_adjustment> &adjustments) const
> {
>    const_cast<cpmds*>(this)->fan_transform(perimeter, adjustments, false);
> }
> 
> void cpmds::fan_transform(const list<unsigned int> &perimeter, map<unsigned int, item_adjustment> &adjustments, bool update)
758c982
<    for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>    for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
775c999
<    for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>    for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
777c1001
<       vector<unsigned int>::const_iterator next_itr = itr;
---
>       list<unsigned int>::const_iterator next_itr = itr;
781c1005
<       vector<unsigned int>::const_iterator prev_itr = itr;
---
>       list<unsigned int>::const_iterator prev_itr = itr;
785c1009
<       vector<unsigned int>::const_iterator next_next_itr = next_itr;
---
>       list<unsigned int>::const_iterator next_next_itr = next_itr;
824a1049,1053
>             else
>             {
>                adjustments[a_id].curvature_delta += subtended_half_angle(r_a, r_c);
>                adjustments[c_id].curvature_delta += subtended_half_angle(r_c, r_a);
>             }
852a1082,1103
>          else if (a_id != 0 && b_id != 0)
>          {
>             item_pk::iterator a_itm_itr = itm_pk.find(a_id);
>             double r_a = a_itm_itr->radius;
> 
>             item_pk::iterator b_itm_itr = itm_pk.find(b_id);
>             double r_b = b_itm_itr->radius;
>           
>             adjustments[a_id].curvature_delta += subtended_half_angle(r_a, r_b);
>             adjustments[b_id].curvature_delta += subtended_half_angle(r_b, r_a);
>          }
>          else if (b_id != 0 && c_id != 0)
>          {
>             item_pk::iterator b_itm_itr = itm_pk.find(b_id);
>             double r_b = b_itm_itr->radius;
> 
>             item_pk::iterator c_itm_itr = itm_pk.find(c_id);
>             double r_c = c_itm_itr->radius;
>           
>             adjustments[b_id].curvature_delta += subtended_half_angle(r_b, r_c);
>             adjustments[c_id].curvature_delta += subtended_half_angle(r_c, r_b);
>          }
858c1109
<    for (vector<unsigned int>::const_iterator itr = ++++perimeter.begin(),
---
>    for (list<unsigned int>::const_iterator itr = ++++perimeter.begin(),
868c1119
<          vector<unsigned int>::const_iterator next_itr = itr;
---
>          list<unsigned int>::const_iterator next_itr = itr;
889a1141
>          double r_a = a_itm_itr->radius;
890a1143
>          double r_b = b_itm_itr->radius;
895,896d1147
<             double r_a = a_itm_itr->radius;
<             double r_b = b_itm_itr->radius;
901a1153,1157
>          else
>          {
>             adjustments[a_itm_itr->id].curvature_delta -= subtended_half_angle(r_a, r_b);
>             adjustments[b_itm_itr->id].curvature_delta -= subtended_half_angle(r_b, r_a);
>          }
914a1171,1190
>       else if (first_itm_id != 0 && third_itm_id != 0)
>       {
>          item_pk::iterator a_itm_itr = itm_pk.find(first_itm_id);
>          double r_a = a_itm_itr->radius;
>          item_pk::iterator c_itm_itr = itm_pk.find(third_itm_id);
>          double r_c = c_itm_itr->radius;
> 
>          adjustments[a_itm_itr->id].curvature_delta -= subtended_half_angle(r_a, r_c);
>          adjustments[c_itm_itr->id].curvature_delta -= subtended_half_angle(r_c, r_a);
>       }
>       else if (second_itm_id != 0 && third_itm_id != 0)
>       {
>          item_pk::iterator b_itm_itr = itm_pk.find(second_itm_id);
>          double r_b = b_itm_itr->radius;
>          item_pk::iterator c_itm_itr = itm_pk.find(third_itm_id);
>          double r_c = c_itm_itr->radius;
> 
>          adjustments[b_itm_itr->id].curvature_delta -= subtended_half_angle(r_b, r_c);
>          adjustments[c_itm_itr->id].curvature_delta -= subtended_half_angle(r_c, r_b);
>       }
933c1209
<       for (vector<unsigned int>::const_iterator itr = ++++perimeter.begin(), end = --perimeter.end(); itr != end; ++itr)
---
>       for (list<unsigned int>::const_iterator itr = ++++perimeter.begin(), end = --perimeter.end(); itr != end; ++itr)
1008c1284
< void cpmds::get_inward_ordering(vector<adjacency_face> &ordering)
---
> void cpmds::get_inward_ordering(list<adjacency_face> &ordering)
1014c1290
<    vector<pair<unsigned int, unsigned int> > border_adjacency_edges;
---
>    list<pair<unsigned int, unsigned int> > border_adjacency_edges;
1038c1314
<       vector<pair<unsigned int, unsigned int> > previous_border_adjacency_edges = border_adjacency_edges;
---
>       list<pair<unsigned int, unsigned int> > previous_border_adjacency_edges = border_adjacency_edges;
1041c1317
<       for (vector<pair<unsigned int, unsigned int> >::const_iterator edge_itr = previous_border_adjacency_edges.begin(), end = previous_border_adjacency_edges.end(); edge_itr != end; ++edge_itr)
---
>       for (list<pair<unsigned int, unsigned int> >::const_iterator edge_itr = previous_border_adjacency_edges.begin(), end = previous_border_adjacency_edges.end(); edge_itr != end; ++edge_itr)
1097c1373
<    cout << "Stress (DIST, AVG): " << get_weighted_measure(DISTANCE, AVG).second << endl;
---
>    //cout << "Stress (DIST, AVG): " << get_weighted_measure(DISTANCE, AVG).second << endl;
1099,1100c1375,1376
<    cout << "Stress (RANK, MIN): " << get_weighted_measure(RANK, MIN).second << endl;
<    cout << "Stress (RANK, MAX): " << get_weighted_measure(RANK, MAX).second << endl;
---
>    //cout << "Stress (RANK, MIN): " << get_weighted_measure(RANK, MIN).second << endl;
>    //cout << "Stress (RANK, MAX): " << get_weighted_measure(RANK, MAX).second << endl;
1107c1383,1384
<    map<unsigned int, unsigned int> rank_frequency;
---
>    vector<unsigned int> rank_frequency(item_table.size(), 0);
>   
1109d1385
<    unsigned int i = 0;
1112,1113c1388
<       rank_frequency[i] = 0;
<       vector<unsigned int> perimeter; 
---
>       list<unsigned int> perimeter; 
1115c1390
<       for (vector<unsigned int>::const_iterator per_itr = perimeter.begin(), per_end = perimeter.end(); per_itr != per_end; ++per_itr)
---
>       for (list<unsigned int>::const_iterator per_itr = perimeter.begin(), per_end = perimeter.end(); per_itr != per_end; ++per_itr)
1117,1118c1392,1396
<          pair<double, double> rank = get_weighted_measure(itm_itr->id, *per_itr, RANK);
<          ++rank_frequency[rank.second];
---
>          if (*per_itr != 0)
>          {
>             pair<double, double> rank = get_weighted_measure(itm_itr->id, *per_itr, RANK);
>             ++rank_frequency[rank.second];
>          }
1120,1121d1397
< 
<       ++i;
1124c1400
<    for (map<unsigned int, unsigned int>::const_iterator itr = rank_frequency.begin(), end = rank_frequency.end(); itr != end; ++itr)
---
>    for (unsigned int i = 0; i < rank_frequency.size(); ++i)
1126c1402
<       fout << itr->first << ", " << itr->second << endl;
---
>       fout << i << ", " << rank_frequency[i] << endl;
1133a1410,1414
>    if (_flattened_items.size() == item_table.size())
>    {
>       reset_flatten();
>    }
> 
1138c1419
<          vector<adjacency_face> face_order;
---
>          list<adjacency_face> face_order;
1146a1428
>                _flattened_boundary_items.insert(make_pair(innermost_vertex, _flattened_boundary.begin()));
1158c1440
<             // TODO Maintain a sorted list when calculating the self joins
---
>             // TODO Maintain a sorted list when calculating the self joins?
1163a1446,1449
>             //for (;self_join_pk_itr != self_join_pk_end; ++self_join_pk_itr)
>             //{
>             //   if (!is_flattened_item(self_join_pk_itr->second_itm_id)) ++boundary_self_connectivity;
>             //}
1168a1455,1458
>             //for (;self_join_r_idx_itr != self_join_r_idx_end; ++self_join_r_idx_itr)
>             //{
>             //   if (!is_flattened_item(self_join_r_idx_itr->second_itm_id)) ++boundary_self_connectivity;
>             //}
1173c1463
<                vector<unsigned int> boundary_perimeter;
---
>                list<unsigned int> boundary_perimeter;
1179c1469
<                for (vector<unsigned int>::const_iterator perimeter_itr = boundary_perimeter.begin(), perimeter_end = boundary_perimeter.end(); perimeter_itr != perimeter_end; ++perimeter_itr)
---
>                for (list<unsigned int>::const_iterator perimeter_itr = boundary_perimeter.begin(), perimeter_end = boundary_perimeter.end(); perimeter_itr != perimeter_end; ++perimeter_itr)
1255c1545
<          vector<unsigned int> perimeter;
---
>          list<unsigned int> perimeter;
1258c1548
<          for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>          for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
1269c1559
<             for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>             for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
1304d1593
<       reset_flatten();
1313d1601
<    item_pk& itm_pk = item_table.get<item_pk_type>();
1315c1603
< 
---
>    item_pk& itm_pk = item_table.get<item_pk_type>();
1317d1604
<    double r = itm_itr->radius;
1322,1323d1608
<    vector<unsigned int> perimeter;
<    get_perimeter(id, perimeter);
1325c1610
<    if (perimeter.front() == 0)
---
>    if (!is_interior_item(id))
1327c1612,1614
<       // An exterior item
---
>       // First try to convert to interior
>       list<unsigned int> perimeter;
>       get_perimeter(id, perimeter);
1328a1616
> 
1332c1620,1621
<       // There must be at least three interior items to ensure planarity
---
>       // There must be at least three exterior items to ensure planarity
>       // Also ensure we didn't previously convert his item to an exterior item
1336a1626
>          // TODO: Let the perimeter boundary items be flattened as long as they still will have valid curvature
1338c1628,1630
<          if (find_adjacency_face(*(++perimeter.begin()), perimeter.back(), f_tmp) == adf_pk.end())
---
>          if (//_flattened_items.find(*(++perimeter.begin())) == _flattened_items.end() &&
>              //_flattened_items.find(perimeter.back()) == _flattened_items.end() &&
>              find_adjacency_face(*(++perimeter.begin()), perimeter.back(), f_tmp) == adf_pk.end())
1342c1634
<             vector<unsigned int> fan_trfm_perimeter;
---
>             list<unsigned int> fan_trfm_perimeter;
1352,1373c1644
<       }
<    }
<    else 
<    {
<       double curvature_tolerance = M_PI / 6;
< 
<       // An interior item
<       vector<unsigned int> fan_trfm_perimeter;
<       vector<unsigned int> ext_rot_perimeter;
<       double lowest_stress_delta  = numeric_limits<double>::max();
<       double adjusted_curvature = itm_itr->curvature;
<       map<unsigned int, double>::const_iterator curvature_adjustment_itr = _curvature_adjustments.find(id);
<       if (curvature_adjustment_itr != _curvature_adjustments.end())
<       {
<          adjusted_curvature += curvature_adjustment_itr->second;
<       }
< 
< 
<       if (adjusted_curvature + curvature_tolerance < 0) 
<       {
<          // Push out the curvature, find the least similar adjacent node
<          for (vector<unsigned int>::const_iterator pivot_itr = perimeter.begin(), end = perimeter.end(); pivot_itr != end; ++pivot_itr)
---
>          else if (itm_itr->curvature < 0)
1375,1376c1646,1659
<             // Seek to disconnect [id] from [pivot]
<             bool potential_fan_trfm_clockwise = true;
---
>             // Unable to convert to interior and the curvature is still unacceptable
>             // Disconnect from the least similar adjacent perimeter item
>             double lowest_stress_delta = numeric_limits<double>::max();
>             list<unsigned int> fan_trfm_perimeter;
>             bool clockwise_perimeter = false;
> 
>             unsigned int constrained_connectivity = 0;
>             list<unsigned int> perimeter;
>             get_perimeter(id, perimeter); 
>             for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
>             { 
>                if (*itr != 0 && is_flattened_item(*itr)) ++constrained_connectivity;
>             }
> 
1379,1380c1662,1666
<                vector<unsigned int>::const_iterator other_itr = pivot_itr;
<                if (potential_fan_trfm_clockwise) 
---
>                list<unsigned int> potential_fan_trfm_perimeter;
>                potential_fan_trfm_perimeter.push_back(0);
> 
>                adjacency_face f_outer, f_inner;
>                if (clockwise_perimeter)
1382,1383c1668,1673
<                   if (other_itr == perimeter.begin()) other_itr = perimeter.end();
<                   --other_itr;
---
>                   find_adjacency_face(id, 0, f_outer);
>                   potential_fan_trfm_perimeter.push_back(f_outer.third_itm_id);
> 
>                   find_adjacency_face(id, f_outer.third_itm_id, f_inner);
>                   potential_fan_trfm_perimeter.push_back(f_inner.third_itm_id);
>                   potential_fan_trfm_perimeter.push_back(id);
1387,1389c1677,1678
<                   ++other_itr;
<                   if (other_itr == perimeter.end()) other_itr = perimeter.begin();
<                }
---
>                   find_adjacency_face(0, id, f_outer);
>                   potential_fan_trfm_perimeter.push_back(id);
1391,1394c1680,1683
<                // The curvature of [pivot] and [other] will be significantly changed
<                if (_flattened_items.find(*other_itr) == _flattened_items.end() &&
<                    _flattened_items.find(*pivot_itr) == _flattened_items.end())
<                {
---
>                   find_adjacency_face(f_outer.third_itm_id, id, f_inner);
>                   potential_fan_trfm_perimeter.push_back(f_inner.third_itm_id);
>                   potential_fan_trfm_perimeter.push_back(f_outer.third_itm_id);
>                }
1396,1398c1685
<                   vector<unsigned int> pivot_perimeter;
<                   get_perimeter(*pivot_itr, pivot_perimeter);
<                   if (potential_fan_trfm_clockwise) reverse(pivot_perimeter.begin(), pivot_perimeter.end());
---
>                item_pk::const_iterator disconnected_itm_itr = itm_pk.find(f_outer.third_itm_id);
1400,1401c1687,1692
<                   vector<unsigned int>::iterator pivot_id_itr = find(pivot_perimeter.begin(), pivot_perimeter.end(), id);
<                   rotate(pivot_perimeter.begin(), pivot_id_itr, pivot_perimeter.end());
---
>                // Make sure we never disconnect this item from the flattened area
>                if (disconnected_itm_itr->connectivity > 2 && 
>                    (!is_flattened_item(f_outer.third_itm_id) || constrained_connectivity > 2))
>                {
>                   map<unsigned int, item_adjustment> adjustments;
>                   fan_transform(potential_fan_trfm_perimeter, adjustments, false);
1403,1410c1694,1695
<                   vector<unsigned int> potential_fan_trfm_perimeter;
<                   potential_fan_trfm_perimeter.push_back(*pivot_itr);
<                   if (potential_fan_trfm_clockwise)
<                   {  
<                      potential_fan_trfm_perimeter.push_back(id);
<                      potential_fan_trfm_perimeter.push_back(*other_itr);
<                   }
<                   else
---
>                   double stress_delta = 0;
>                   for (map<unsigned int, item_adjustment>::const_iterator itr = adjustments.begin(), end = adjustments.end(); itr != end; ++itr)
1412,1413c1697,1698
<                      potential_fan_trfm_perimeter.push_back(*other_itr);
<                      potential_fan_trfm_perimeter.push_back(id);
---
>                      item_pk::const_iterator adj_itm_itr = itm_pk.find(itr->first);
>                      stress_delta += (itr->second.distance_weight_sum_delta - itr->second.weight_sum_delta * adj_itm_itr->distance_weight_sum / adj_itm_itr->weight_sum) / (adj_itm_itr->weight_sum + itr->second.weight_sum_delta);
1416,1418c1701
<                   // Ensure that the joined neighbours of [id] are not already connected (separating triangle)
<                   adjacency_face f_tmp;
<                   if (find_adjacency_face(*other_itr, *(++pivot_perimeter.begin()), f_tmp) == adf_pk.end())
---
>                   if (stress_delta <= lowest_stress_delta)
1420,1429c1703,1707
<                      for (vector<unsigned int>::iterator pivot_last_itr = ++pivot_perimeter.begin(), pivot_other_itr = --pivot_perimeter.end(); pivot_last_itr != pivot_other_itr && potential_fan_trfm_perimeter.size() < 5; ++pivot_last_itr)
<                      {
<                         if (potential_fan_trfm_clockwise)
<                         {
<                            potential_fan_trfm_perimeter.insert(potential_fan_trfm_perimeter.begin() + 1, *pivot_last_itr);
<                         }
<                         else
<                         {
<                            potential_fan_trfm_perimeter.push_back(*pivot_last_itr);
<                         }
---
>                      lowest_stress_delta = stress_delta;
>                      fan_trfm_perimeter.clear();
>                      copy(potential_fan_trfm_perimeter.begin(), potential_fan_trfm_perimeter.end(), back_inserter(fan_trfm_perimeter));
>                   }
>                }
1431,1488c1709,1711
<                         if (_flattened_items.find(*pivot_last_itr) == _flattened_items.end())
<                         {
<                            if (potential_fan_trfm_clockwise)
<                               rotate(potential_fan_trfm_perimeter.begin(),
<                                      potential_fan_trfm_perimeter.end() - 1,
<                                      potential_fan_trfm_perimeter.end());
<                            else
<                               rotate(potential_fan_trfm_perimeter.begin(),
<                                      potential_fan_trfm_perimeter.begin() + 1,
<                                      potential_fan_trfm_perimeter.end());
< 
<                            bool can_adjust = true;
<                            map<unsigned int, item_adjustment> adjustments;
<                            fan_transform(potential_fan_trfm_perimeter, adjustments, false);
<                            if (potential_fan_trfm_perimeter.size() > 4)
<                            {
<                               // There will be a small adjustment to the flattened item, check to see if it is acceptable
<                               vector<unsigned int>::const_iterator minor_adjust_itr = pivot_last_itr;
<                               --minor_adjust_itr;
< 
<                               if (_flattened_items.find(*minor_adjust_itr) != _flattened_items.end())
<                               {
< 
<                                  if (!is_beneficial_adjustment(*minor_adjust_itr, adjustments[*minor_adjust_itr].curvature_delta))
<                                  {
<                                     can_adjust = false;
<                                  }
<                               }
<                            }
< 
<                            if (can_adjust)
<                            {
<                               double stress_delta = 0;
<                               for (map<unsigned int, item_adjustment>::const_iterator itr = adjustments.begin(), end = adjustments.end(); itr != end; ++itr)
<                               {
<                                  item_pk::const_iterator adj_itm_itr = itm_pk.find(itr->first);
<                                  stress_delta += (itr->second.distance_weight_sum_delta - itr->second.weight_sum_delta * adj_itm_itr->distance_weight_sum / adj_itm_itr->weight_sum)
<                                                  / (adj_itm_itr->weight_sum + itr->second.weight_sum_delta);
<                               }
< 
<                               if (stress_delta <= lowest_stress_delta)
<                               {
<                                  lowest_stress_delta = stress_delta;
<                                  //cout << "Lowest stress delta - " << lowest_stress_delta << endl;
<                                  fan_trfm_perimeter.clear();
<                                  copy(potential_fan_trfm_perimeter.begin(), potential_fan_trfm_perimeter.end(), back_inserter(fan_trfm_perimeter));
<                               }
<                            }
< 
< 
<                            if (potential_fan_trfm_clockwise)
<                               rotate(potential_fan_trfm_perimeter.begin(),
<                                      potential_fan_trfm_perimeter.begin() + 1,
<                                      potential_fan_trfm_perimeter.end());
<                            else
<                               rotate(potential_fan_trfm_perimeter.begin(),
<                                      potential_fan_trfm_perimeter.end() - 1,
<                                      potential_fan_trfm_perimeter.end());
---
>                clockwise_perimeter = !clockwise_perimeter;
>             } 
>             while (clockwise_perimeter != false);
1489a1713,1717
>             if (!fan_trfm_perimeter.empty())
>             {
>                map<unsigned int, item_adjustment> adjustments;
>                fan_transform(fan_trfm_perimeter, adjustments, true);
>                is_acceptable_curvature = false;
1491,1492c1719,1731
<                         }
<                      }
---
>                // Update the flattened boundary in the case where the new boundary is flattened
>                clockwise_perimeter = (*++fan_trfm_perimeter.begin() != id);
>                list<unsigned int> new_boundary;
>                new_boundary.push_back(*++++fan_trfm_perimeter.begin());
>                unsigned int old_boundary = (clockwise_perimeter ? *++fan_trfm_perimeter.begin() : *++++++fan_trfm_perimeter.begin());
>                
>                if (is_flattened_item(new_boundary.front()))
>                {
>                   list<unsigned int>::iterator insert_itr = _flattened_boundary_items[old_boundary];
>                   if (!clockwise_perimeter)
>                   {
>                      insert_itr++;
>                      if (insert_itr == _flattened_boundary.end()) insert_itr = _flattened_boundary.begin();
1493a1733,1742
> 
>                   for (list<unsigned int>::const_iterator new_boundary_itr = new_boundary.begin(), new_boundary_end = new_boundary.end(); new_boundary_itr != new_boundary_end; ++new_boundary_itr)
>                   {
>                      insert_itr = _flattened_boundary.insert(insert_itr, *new_boundary_itr);
>                      _flattened_boundary_items.insert(make_pair(*new_boundary_itr, insert_itr));
>                      ++insert_itr;
>                   }
> 
>                   find_joins(new_boundary.begin(), new_boundary.end(),
>                              _flattened_boundary.begin(), _flattened_boundary.end());
1496c1745
<                potential_fan_trfm_clockwise = !potential_fan_trfm_clockwise;
---
>                cout << "Disconnecting perimeter item " << id << " from " << old_boundary << endl;
1498d1746
<             while (potential_fan_trfm_clockwise == false);
1499a1748,1766
>       }
>    }
>    else 
>    {
>       // An interior item
>       double curvature_tolerance = M_PI / 6;
>       double adjusted_curvature = itm_itr->curvature;
>       map<unsigned int, double>::const_iterator curvature_adjustment_itr = _curvature_adjustments.find(id);
>       if (curvature_adjustment_itr != _curvature_adjustments.end())
>       {
>          adjusted_curvature += curvature_adjustment_itr->second;
>       }
> 
>       list<unsigned int> fan_trfm_perimeter;
> 
>       if (adjusted_curvature + curvature_tolerance < 0) 
>       {
>          fan_trfm_perimeter.clear();
>          get_increase_curvature_transform(id, fan_trfm_perimeter);
1504c1771
<             cout << "Increasing " << id << " curvature (was " << itm_itr->curvature * 180 / M_PI << ", by moving " << fan_trfm_perimeter.back() << " away from " << fan_trfm_perimeter[1] << ")." << endl;
---
>             cout << "Increasing " << id << " curvature (was " << itm_itr->curvature * 180 / M_PI << ", by moving " << fan_trfm_perimeter.back() << " away from " << *++fan_trfm_perimeter.begin() << ")." << endl;
1524,1525c1791,1792
<                vector<unsigned int> new_boundary;
<                new_boundary.push_back(fan_trfm_perimeter[0]);
---
>                list<unsigned int> new_boundary;
>                new_boundary.push_back(*fan_trfm_perimeter.begin());
1527c1794
<                if (id == fan_trfm_perimeter[1])
---
>                if (id == *++fan_trfm_perimeter.begin())
1530c1797
<                   adjusted_item = fan_trfm_perimeter[2];
---
>                   adjusted_item = *++++fan_trfm_perimeter.begin();
1534,1535c1801,1802
<                   old_boundary = fan_trfm_perimeter[1];
<                   adjusted_item = fan_trfm_perimeter[3];
---
>                   old_boundary = *++fan_trfm_perimeter.begin();
>                   adjusted_item = *++++++fan_trfm_perimeter.begin();
1540,1544c1807
<                   list<unsigned int>::iterator boundary_itr = find(_flattened_boundary.begin(), 
<                                                                    _flattened_boundary.end(),
<                                                                    old_boundary);
< 
<                   if (boundary_itr != _flattened_boundary.end())
---
>                   if (_flattened_boundary_items.find(old_boundary) != _flattened_boundary_items.end())
1545a1809
>                      list<unsigned int>::iterator insert_itr = _flattened_boundary_items[old_boundary];
1549c1813
<                      vector<unsigned int> old_boundary_perimeter;
---
>                      list<unsigned int> old_boundary_perimeter;
1551c1815
<                      for (vector<unsigned int>::const_iterator itr = old_boundary_perimeter.begin(), end = old_boundary_perimeter.end(); itr != end; ++itr)
---
>                      for (list<unsigned int>::const_iterator itr = old_boundary_perimeter.begin(), end = old_boundary_perimeter.end(); itr != end; ++itr)
1562c1826,1830
<                         if (fan_trfm_perimeter[1] == id) ++boundary_itr;
---
>                         if (*++fan_trfm_perimeter.begin() == id)
>                         {
>                            ++insert_itr;
>                            if (insert_itr == _flattened_boundary.end()) insert_itr = _flattened_boundary.begin();
>                         }
1566c1834,1835
<                         boundary_itr = _flattened_boundary.erase(boundary_itr);
---
>                         _flattened_boundary_items.erase(*insert_itr);
>                         insert_itr = _flattened_boundary.erase(insert_itr);
1569,1577c1838
<                         boundary_self_join_pk& bsj_pk = boundary_self_join_table.get<boundary_self_join_pk_type>();
<                         boundary_self_join_pk::const_iterator self_join_pk_itr, self_join_pk_end;
<                         tie(self_join_pk_itr, self_join_pk_end) = bsj_pk.equal_range(old_boundary); 
<                         bsj_pk.erase(self_join_pk_itr, self_join_pk_end);
< 
<                         boundary_self_join_reverse_idx& bsj_reverse_idx = boundary_self_join_table.get<boundary_self_join_reverse_idx_type>();
<                         boundary_self_join_reverse_idx::const_iterator self_join_r_idx_itr, self_join_r_idx_end;
<                         tie(self_join_r_idx_itr, self_join_r_idx_end) = bsj_reverse_idx.equal_range(old_boundary); 
<                         bsj_reverse_idx.erase(self_join_r_idx_itr, self_join_r_idx_end);
---
>                         remove_boundary_self_joins(old_boundary);
1580c1841,1846
<                      _flattened_boundary.insert(boundary_itr, new_boundary.begin(), new_boundary.end());
---
>                      for (list<unsigned int>::const_iterator new_boundary_itr = new_boundary.begin(), new_boundary_end = new_boundary.end(); new_boundary_itr != new_boundary_end; ++new_boundary_itr)
>                      {
>                         insert_itr = _flattened_boundary.insert(insert_itr, *new_boundary_itr);
>                         _flattened_boundary_items.insert(make_pair(*new_boundary_itr, insert_itr));
>                         ++insert_itr;
>                      }
1598,1599c1864,1865
<             vector<unsigned int>::const_iterator itr = find(fan_trfm_perimeter.begin(), fan_trfm_perimeter.end(), id);
<             vector<unsigned int>::const_iterator next_itr = itr;
---
>             list<unsigned int>::const_iterator itr = find(fan_trfm_perimeter.begin(), fan_trfm_perimeter.end(), id);
>             list<unsigned int>::const_iterator next_itr = itr;
1603c1869
<             vector<unsigned int>::const_iterator prev_itr = itr;
---
>             list<unsigned int>::const_iterator prev_itr = itr;
1612a1879
>                double r = itm_itr->radius;
1626c1893
<                   //for (vector<unsigned int>::const_iterator itr = fan_trfm_perimeter.begin(), end = fan_trfm_perimeter.end(); itr != end; ++itr)
---
>                   //for (list<unsigned int>::const_iterator itr = fan_trfm_perimeter.begin(), end = fan_trfm_perimeter.end(); itr != end; ++itr)
1667,1670c1934
<    // Update the boundary
<    list<unsigned int>::iterator boundary_itr = find(_flattened_boundary.begin(), 
<                                                     _flattened_boundary.end(),
<                                                     id);
---
>    if (_flattened_boundary_items.find(id) == _flattened_boundary_items.end()) return;
1672,1674c1936,1953
<    list<unsigned int>::iterator boundary_next_itr = _flattened_boundary.erase(boundary_itr);
<    if (boundary_next_itr == _flattened_boundary.end())
<       boundary_next_itr = _flattened_boundary.begin();
---
>    // Update the boundary
>    list<unsigned int>::iterator itr = _flattened_boundary_items[id];
>          
>    list<unsigned int>::iterator prev_itr = itr;
>    if (prev_itr == _flattened_boundary.begin()) prev_itr = _flattened_boundary.end();
>    --prev_itr;
> 
>    list<unsigned int>::iterator next_itr = itr;
>    ++next_itr;
>    if (next_itr == _flattened_boundary.end()) next_itr = _flattened_boundary.begin();
> 
>    // Find the new perimeter
>    list<unsigned int> perimeter;
>    get_perimeter(id, perimeter, *prev_itr, *next_itr);
> 
>    // If an exterior vertex, do not delete this vertex from the boundary
>    list<unsigned int>::iterator edge_itr = find(perimeter.begin(), perimeter.end(), 0);
>    if (edge_itr != perimeter.end()) *edge_itr = id;
1676,1679c1955,1959
<    list<unsigned int>::iterator boundary_prev_itr = boundary_next_itr;
<    if (boundary_prev_itr == _flattened_boundary.begin())
<       boundary_prev_itr = _flattened_boundary.end();
<    --boundary_prev_itr;
---
>    // Update the boundary
>    _flattened_boundary_items.erase(*itr);
>    list<unsigned int>::iterator insert_itr = _flattened_boundary.erase(itr);
>    list<unsigned int>::iterator new_boundary_start_itr = perimeter.begin(); 
>    list<unsigned int>::iterator new_boundary_end_itr = perimeter.end(); 
1681,1683c1961
<    // Ensure that boundary items are not double counted 
<    if (_flattened_boundary.size() > 1 &&
<        *boundary_prev_itr == *boundary_next_itr)
---
>    if (_flattened_boundary.size() != 0 && perimeter.size() >= 2)
1685,1687c1963,1964
<       boundary_prev_itr = _flattened_boundary.erase(boundary_prev_itr);
<       if (boundary_prev_itr == _flattened_boundary.end())
<             boundary_prev_itr = _flattened_boundary.begin();
---
>       ++new_boundary_start_itr;
>       --new_boundary_end_itr;
1689a1967,1972
>    for (list<unsigned int>::const_iterator new_boundary_itr = new_boundary_start_itr, new_boundary_end = new_boundary_end_itr; new_boundary_itr != new_boundary_end; ++new_boundary_itr)
>    {
>       insert_itr = _flattened_boundary.insert(insert_itr, *new_boundary_itr);
>       _flattened_boundary_items.insert(make_pair(*new_boundary_itr, insert_itr));
>       ++insert_itr;
>    }
1691,1695c1974,1975
<    vector<unsigned int> perimeter;
<    get_perimeter(id, perimeter);
< 
<    // Ensure that boundary items remain in the boundary (add back in)
<    if (perimeter.front() == 0) perimeter.front() = id;
---
>    find_joins(new_boundary_start_itr, new_boundary_end_itr, 
>               _flattened_boundary.begin(), _flattened_boundary.end());
1697,1699c1977
<    if (boundary_next_itr == _flattened_boundary.end())
<    {
<       copy(perimeter.begin(), perimeter.end(), back_inserter(_flattened_boundary));
---
>    remove_boundary_self_joins(id);
1701,1704c1979
<       find_joins(perimeter.begin(), perimeter.end(),
<                  _flattened_boundary.begin(), _flattened_boundary.end());
<    }
<    else
---
>    if (!is_interior_item(id))
1705a1981,1984
>       // Add back in the outward joins to the boundary
>       list<unsigned int>::iterator edge_prev_itr = edge_itr;
>       if (edge_prev_itr == perimeter.begin()) edge_prev_itr == perimeter.end();
>       --edge_prev_itr;
1707,1736c1986,1988
<       if (*boundary_next_itr != *boundary_prev_itr)
<       {
<          vector<unsigned int>::iterator perimeter_start_itr = find(perimeter.begin(),
<                                                                    perimeter.end(),
<                                                                    *boundary_prev_itr); 
<          if (perimeter_start_itr != perimeter.end())
<          {
<             ++perimeter_start_itr;
<             if (perimeter_start_itr == perimeter.end())
<                perimeter_start_itr = perimeter.begin();
< 
<             vector<unsigned int>::iterator perimeter_end_itr = find(perimeter_start_itr,
<                                                                     perimeter.end(),
<                                                                     *boundary_next_itr); 
<             if (perimeter_end_itr != perimeter.end())
<             {
<                _flattened_boundary.insert(boundary_next_itr, perimeter_start_itr, perimeter_end_itr);
<                 find_joins(perimeter_start_itr, perimeter_end_itr, 
<                           _flattened_boundary.begin(), _flattened_boundary.end());
<             }
<             else
<             {
<                vector<unsigned int>::iterator perimeter_prior_end_itr = find(perimeter.begin(),
<                                                                         perimeter_start_itr,
<                                                                         *boundary_next_itr); 
<                 
<                if (perimeter_prior_end_itr != perimeter_start_itr)
<                {
<                   _flattened_boundary.insert(boundary_next_itr, perimeter_start_itr, perimeter_end_itr);
<                   _flattened_boundary.insert(boundary_next_itr, perimeter.begin(), perimeter_prior_end_itr);
---
>       list<unsigned int>::iterator edge_next_itr = edge_itr;
>       ++edge_next_itr;
>       if (edge_next_itr == perimeter.end()) edge_next_itr = perimeter.begin();
1738,1745c1990,1991
<                   find_joins(perimeter.begin(), perimeter_prior_end_itr,
<                              _flattened_boundary.begin(), _flattened_boundary.end());
<                   find_joins(perimeter_start_itr, perimeter_end_itr, 
<                              _flattened_boundary.begin(), _flattened_boundary.end());
<                }
<             }
<          }
<       }
---
>       check_boundary_self_join(id, *edge_prev_itr);
>       check_boundary_self_join(id, *edge_next_itr);
1748,1760d1993
<    //if (is_interior_item(id))
<    {
<       // Update the boundary self connectivity graph
<       boundary_self_join_pk& bsj_pk = boundary_self_join_table.get<boundary_self_join_pk_type>();
<       boundary_self_join_pk::const_iterator self_join_pk_itr, self_join_pk_end;
<       tie(self_join_pk_itr, self_join_pk_end) = bsj_pk.equal_range(id); 
<       bsj_pk.erase(self_join_pk_itr, self_join_pk_end);
< 
<       boundary_self_join_reverse_idx& bsj_reverse_idx = boundary_self_join_table.get<boundary_self_join_reverse_idx_type>();
<       boundary_self_join_reverse_idx::const_iterator self_join_r_idx_itr, self_join_r_idx_end;
<       tie(self_join_r_idx_itr, self_join_r_idx_end) = bsj_reverse_idx.equal_range(id); 
<       bsj_reverse_idx.erase(self_join_r_idx_itr, self_join_r_idx_end);
<    }
1779c2012,2039
<    return find(_flattened_boundary.begin(), _flattened_boundary.end(), id) != _flattened_boundary.end();
---
>    return _flattened_boundary_items.find(id) != _flattened_boundary_items.end();
> }
> 
> bool cpmds::is_boundary_edge(unsigned int first_itm_id, unsigned int second_itm_id) const
> {
>    bool is_edge = false;
>    map<unsigned int, list<unsigned int>::iterator>::const_iterator boundary_itr = _flattened_boundary_items.find(first_itm_id);
>    if (boundary_itr != _flattened_boundary_items.end())
>    {
>       list<unsigned int>::const_iterator first_itr = boundary_itr->second;
> 
>       list<unsigned int>::const_iterator prev_itr = first_itr;
>       if (prev_itr == _flattened_boundary.begin()) prev_itr = _flattened_boundary.end();
>       --prev_itr;
> 
>       if (second_itm_id == *prev_itr) is_edge = true;
>       else
>       {
>          list<unsigned int>::const_iterator next_itr = first_itr;
>          ++next_itr;
>          if (next_itr == _flattened_boundary.end()) next_itr = _flattened_boundary.begin();
> 
>          if (second_itm_id == *next_itr) is_edge = true;
>       }
> 
>    }
> 
>    return is_edge;
1794,1800c2054,2057
<    boundary_self_join_pk::iterator itr = bsj_pk.find(boost::make_tuple(first_itm_id, second_itm_id));
<    if (itr != bsj_pk.end())
<    {
<       bsj_pk.erase(itr);
<    }
<   
<    itr = bsj_pk.find(boost::make_tuple(second_itm_id, first_itm_id));
---
>    pair<unsigned int, unsigned int> lower_higher_id = first_itm_id > second_itm_id
>                                                      ? make_pair(second_itm_id, first_itm_id) 
>                                                      : make_pair(first_itm_id, second_itm_id);
>    boundary_self_join_pk::iterator itr = bsj_pk.find(boost::make_tuple(lower_higher_id.first, lower_higher_id.second));
1806a2064,2077
> void cpmds::remove_boundary_self_joins(unsigned int id)
> {
>    // Update the boundary self connectivity graph
>    boundary_self_join_pk& bsj_pk = boundary_self_join_table.get<boundary_self_join_pk_type>();
>    boundary_self_join_pk::const_iterator self_join_pk_itr, self_join_pk_end;
>    tie(self_join_pk_itr, self_join_pk_end) = bsj_pk.equal_range(id); 
>    bsj_pk.erase(self_join_pk_itr, self_join_pk_end);
> 
>    boundary_self_join_reverse_idx& bsj_reverse_idx = boundary_self_join_table.get<boundary_self_join_reverse_idx_type>();
>    boundary_self_join_reverse_idx::const_iterator self_join_r_idx_itr, self_join_r_idx_end;
>    tie(self_join_r_idx_itr, self_join_r_idx_end) = bsj_reverse_idx.equal_range(id); 
>    bsj_reverse_idx.erase(self_join_r_idx_itr, self_join_r_idx_end);
> }
> 
1816,1817c2087,2088
<       if (find(_flattened_boundary.begin(), _flattened_boundary.end(), first_itm_id) != _flattened_boundary.end() &&
<           find(_flattened_boundary.begin(), _flattened_boundary.end(), second_itm_id) != _flattened_boundary.end())
---
>       if (_flattened_boundary_items.find(first_itm_id) != _flattened_boundary_items.end() &&
>           _flattened_boundary_items.find(second_itm_id) != _flattened_boundary_items.end())
1829,1830c2100,2101
< void cpmds::find_joins(vector<unsigned int>::const_iterator left_begin_itr,
<                        vector<unsigned int>::const_iterator left_end_itr,
---
> void cpmds::find_joins(list<unsigned int>::const_iterator left_begin_itr,
>                        list<unsigned int>::const_iterator left_end_itr,
1837c2108
<    for (vector<unsigned int>::const_iterator left_itr = left_begin_itr; left_itr != left_end_itr; ++left_itr)
---
>    for (list<unsigned int>::const_iterator left_itr = left_begin_itr; left_itr != left_end_itr; ++left_itr)
1849,1851c2120
<                if (bsj_pk.find(boost::make_tuple(lower_higher_id.first, lower_higher_id.second)) == bsj_pk.end() &&
<                    _flattened_items.find(lower_higher_id.first) == _flattened_items.end() &&
<                    _flattened_items.find(lower_higher_id.second) == _flattened_items.end())
---
>                if (bsj_pk.find(boost::make_tuple(lower_higher_id.first, lower_higher_id.second)) == bsj_pk.end())
1872c2141,2142
<    const double curvature_error_tolerance = 0.001;
---
>    const double curvature_error_tolerance = 1e-6;
>    const double radial_tolerance = 0.01;
1967c2237
<    map<unsigned int, point> itm_locations; // id, location
---
>    map<unsigned int, pair<point, bool> > itm_locations; // id, location, located
1983c2253
<          vector<unsigned int> perimeter;
---
>          list<unsigned int> perimeter;
1994c2264,2267
<             itm_locations.insert(make_pair(id, point(0, 0)));
---
>             itm_locations.insert(make_pair(id, make_pair(point(0, 0), true)));
>             processed_child_items.insert(id);
> 
>             if (perimeter.front() == 0) perimeter.erase(perimeter.begin()); 
2002c2275,2276
<                itm_locations.insert(make_pair(second_itm_id, point(r_a + r_b, 0)));
---
>                itm_locations.insert(make_pair(second_itm_id, make_pair(point(r_a + r_b, 0), true)));
>                processed_child_items.insert(second_itm_id);
2013c2287
<             vector<unsigned int>::iterator parent_itr = find(perimeter.begin(), perimeter.end(), child_parent_itr->second);
---
>             list<unsigned int>::iterator parent_itr = find(perimeter.begin(), perimeter.end(), child_parent_itr->second);
2019c2293
<          for(vector<unsigned int>::const_iterator itr = ++perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>          for(list<unsigned int>::const_iterator itr = ++perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
2021,2024c2295,2296
<             if (*itr != 0 && processed_child_items.find(*itr) == processed_child_items.end())
<             {
<                vector<unsigned int>::const_iterator prior_itr = itr;
<                --prior_itr;
---
>             list<unsigned int>::const_iterator prior_itr = itr;
>             --prior_itr;
2026,2033c2298,2305
<                if (*prior_itr != 0)
<                {
<                   // Locate the perimeter item 
<                   item_pk::const_iterator prior_itm_itr = itm_pk.find(*prior_itr);
<                   item_pk::const_iterator itm_itr = itm_pk.find(*itr);
< 
<                   double r_b = prior_itm_itr->radius;
<                   double r_c = itm_itr->radius;
---
>             if (*itr != 0 && *prior_itr != 0 &&
>                 processed_child_items.find(*itr) == processed_child_items.end() &&
>                 (processed_child_items.find(*prior_itr) != processed_child_items.end() || 
>                  processed_parent_items.find(*prior_itr) != processed_parent_items.end()))
>             {
>                // Locate the perimeter item 
>                item_pk::const_iterator prior_itm_itr = itm_pk.find(*prior_itr);
>                item_pk::const_iterator itm_itr = itm_pk.find(*itr);
2035,2036c2307,2308
<                   point a = itm_locations[id];
<                   point b = itm_locations[*prior_itr];
---
>                double r_b = prior_itm_itr->radius;
>                double r_c = itm_itr->radius;
2038,2048c2310,2311
<                   // Find the position of c assuming it is tangent to both a and b
<                   double ab_length = sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2));
<                   //if (ab_length > (r_a + 2 * r_c + r_b)) 
<                   if (ab_length > (r_a + r_b + 0.1)) 
<                   {
<                      // TODO place beside either A or B
<                      cout << *itr << " cannot be placed. AB length = " << ab_length << ", r_a + r_b = " << r_a + r_b << endl;
<                      cout << "A = " << id << ", B = " << *prior_itr << endl;
<                      while (!pending_items.empty()) pending_items.pop();
<                      break;
<                   }
---
>                point a = itm_locations[id].first;
>                point b = itm_locations[*prior_itr].first;
2050,2061c2313,2328
<                   double cos_alpha = ((r_a + r_c) * (r_a + r_c) + ab_length * ab_length - (r_b + r_c) * (r_b + r_c))
<                                     / (2. * ab_length * (r_a + r_c));
<                   double sin_alpha = sqrt(1 - pow(cos_alpha, 2));
< 
<                   // To find the new point, we move along AB then along the normal
<                   point c(a.x + ((b.x - a.x) / ab_length) * (r_a + r_c) * cos_alpha 
<                               - ((b.y - a.y) / ab_length) * (r_a + r_c) * sin_alpha,
<                           a.y + ((b.y - a.y) / ab_length) * (r_a + r_c) * cos_alpha
<                               + ((b.x - a.x) / ab_length) * (r_a + r_c) * sin_alpha);
<                            
<                   cout << "Laying out " << *itr << " from " << id << " and " << *prior_itr << endl;
<                   itm_locations.insert(make_pair(*itr, c));
---
>                // Find the position of c assuming it is tangent to both a and b
>                double ab_length = sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2));
>                //if (ab_length > (r_a + 2 * r_c + r_b)) 
>                if (ab_length - (r_a + r_b) > ((r_a + r_b) * radial_tolerance)) 
>                {
>                   // TODO place beside either A or B
>                   cout << *itr << " cannot be placed. AB length = " << ab_length << ", r_a + r_b = " << r_a + r_b <<
>                                   ", error % = " << (ab_length - (r_a + r_b)) / (r_a + r_b) <<  " tolerance = " << radial_tolerance << endl;
>                   cout << "A = " << id << ", B = " << *prior_itr << endl;
>                   while (!pending_items.empty()) pending_items.pop();
>                   break;
>                }
>                else
>                {
>                   cout << *itr << ", positional error % = " << (ab_length - (r_a + r_b)) / (r_a + r_b) <<  " tolerance = " << radial_tolerance << endl;
>                }
2063,2067c2330,2341
<                   if (_flattened_items.find(*itr) != _flattened_items.end())
<                   {
<                      child_parent_map.insert(make_pair(*itr, id));
<                      pending_items.push(*itr);
<                   }
---
>                double cos_alpha = ((r_a + r_c) * (r_a + r_c) + ab_length * ab_length - (r_b + r_c) * (r_b + r_c))
>                                  / (2. * ab_length * (r_a + r_c));
>                double sin_alpha = sqrt(1 - pow(cos_alpha, 2));
> 
>                // To find the new point, we move along AB then along the normal
>                point c(a.x + ((b.x - a.x) / ab_length) * (r_a + r_c) * cos_alpha 
>                            - ((b.y - a.y) / ab_length) * (r_a + r_c) * sin_alpha,
>                        a.y + ((b.y - a.y) / ab_length) * (r_a + r_c) * cos_alpha
>                            + ((b.x - a.x) / ab_length) * (r_a + r_c) * sin_alpha);
>                         
>                // cout << "Laying out #" << processed_child_items.size() << " "  << *itr << " from " << id << " and " << *prior_itr << " at " << c << endl;
>                itm_locations.insert(make_pair(*itr, make_pair(c, true)));
2069c2343,2346
<                   processed_child_items.insert(*itr);
---
>                if (_flattened_items.find(*itr) != _flattened_items.end())
>                {
>                   child_parent_map.insert(make_pair(*itr, id));
>                   pending_items.push(*itr);
2070a2348,2349
> 
>                processed_child_items.insert(*itr);
2083c2362
<          itm_locations.insert(make_pair(itr->id, point(10e23, 10e23)));
---
>          itm_locations.insert(make_pair(itr->id, make_pair(point(10e23, 10e23), false)));
2088c2367
<    for (map<unsigned int, point>::const_iterator itr = itm_locations.begin(), end = itm_locations.end(); itr != end; ++itr)
---
>    for (map<unsigned int, pair<point, bool> >::const_iterator itr = itm_locations.begin(), end = itm_locations.end(); itr != end; ++itr)
2092c2371,2372
<       i.location = itr->second;
---
>       i.location = itr->second.first;
>       i.is_located = itr->second.second;
2099c2379
<    vector<unsigned int> vertices;
---
>    list<unsigned int> vertices;
2105,2106c2385,2386
<    vector<pair<double, double> > sub_measures;
<    for (unsigned int i = 0; i < vertices.size(); ++i)
---
>    list<pair<double, double> > sub_measures;
>    for (list<unsigned int>::const_iterator itr = vertices.begin(), end = vertices.end(); itr != end; ++itr)
2108c2388
<       sub_measures.push_back(get_weighted_measure(id, vertices[i], s_type));
---
>       sub_measures.push_back(get_weighted_measure(id, *itr, s_type));
2114c2394
<       for (vector<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
---
>       for (list<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
2124c2404
<       for (vector<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
---
>       for (list<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
2136c2416
<       for (vector<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
---
>       for (list<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
2227a2508
> // Find the angle subtended between AB and AC where A, B, C are the centres of three circles
2232a2514,2519
> // Find the angle subtended between the centre of circle A, the centre of circle B and it's tangent
> double cpmds::subtended_half_angle(double r_a, double r_b)
> {
>    return asin(r_b / (r_a + r_b));
> }
> 
2252c2539,2679
< void cpmds::get_graph_straight_line_drawing(std::map<unsigned int, point> &vertex_locations)
---
> void cpmds::get_graph_afl_drawing(map<unsigned int, point> &vertex_locations)
> {
>    const item_pk& itm_pk = item_table.get<item_pk_type>();
>    if (itm_pk.empty()) return;
> 
>    // Start with an arbitary node, let's take the node with the smallest id
>    unsigned int n0 = itm_pk.begin()->id;
> 
>    // Select [n1] to maximize h[0, 1]
>    map<unsigned int, unsigned int> h0, h1, h2, h3, h4, h5;
>    get_hop_counts(n0, h0);
> 
>    unsigned int n1 = n0;
>    unsigned int h01 = 0;
>    for (map<unsigned int, unsigned int>::const_iterator itr = h0.begin(), end = h0.end(); itr != end; ++itr)
>    {
>       if (itr->second > h01)
>       {
>          h01 = itr->second;
>          n1 = itr->first;
>       }
>    }
> 
>    // Select [n2] to maximize h[1, 2]
>    get_hop_counts(n1, h1);
> 
>    unsigned int n2 = n1;
>    unsigned int h12 = 0;
>    for (map<unsigned int, unsigned int>::const_iterator itr = h1.begin(), end = h1.end(); itr != end; ++itr)
>    {
>       if (itr->second > h12)
>       {
>          h12 = itr->second;
>          n2 = itr->first;
>       }
>    }
> 
>    // Select n3 to minimuze h[1,3] - h[2,3], while maximizing h[1,3] + h[2, 3] in a tie
>    get_hop_counts(n2, h2);
> 
>    unsigned int n3 = n1;
>    unsigned int h13_23_min_diff = numeric_limits<unsigned int>::max();
>    unsigned int h13_23_max_sum  = 0;
>    for (map<unsigned int, unsigned int>::const_iterator h23_itr = h2.begin(), end = h2.end(); h23_itr != end; ++h23_itr)
>    {
>       map<unsigned int, unsigned int>::const_iterator h13_itr = h1.find(h23_itr->first);
> 
>       unsigned int h13_23_diff = h13_itr->second > h23_itr->second ?
>                                  h13_itr->second - h23_itr->second :
>                                  h23_itr->second - h13_itr->second;
>       unsigned int h13_23_sum = h13_itr->second + h23_itr->second;
> 
>       if (h13_23_diff < h13_23_min_diff ||
>           (h13_23_diff == h13_23_min_diff && h13_23_sum > h13_23_max_sum))
>       {
>          h13_23_min_diff = h13_23_diff;
>          h13_23_max_sum = h13_23_sum;
>          n3 = h23_itr->first;
>       }
>    }
>    
>    // Select n4 to minimuze h[1,4] - h[2,4], while maximizing h[3,4] in a tie
>    get_hop_counts(n3, h3);
> 
>    unsigned int n4 = n1;
>    unsigned int h14_24_min_diff = numeric_limits<unsigned int>::max();
>    unsigned int h34_max = 0;
>    for (map<unsigned int, unsigned int>::const_iterator h24_itr = h2.begin(), end = h2.end(); h24_itr != end; ++h24_itr)
>    {
>       map<unsigned int, unsigned int>::const_iterator h14_itr = h1.find(h24_itr->first);
> 
>       unsigned int h14_24_diff = h14_itr->second > h24_itr->second ?
>                                  h14_itr->second - h24_itr->second :
>                                  h24_itr->second - h14_itr->second;
>       unsigned int h34 = h3[h24_itr->first];
> 
>       if (h14_24_diff < h14_24_min_diff ||
>           (h14_24_diff == h14_24_min_diff && h34 > h34_max))
>       {
>          h14_24_min_diff = h14_24_diff;
>          h34_max = h34;
>          n4 = h24_itr->first;
>       }
>    }
> 
>    // Select n5 to minimize h[1,5] - h[2,5], while minimizing h[3,5] - h[4,5] in a tie
>    get_hop_counts(n4, h4);
> 
>    unsigned int n5 = n1;
>    unsigned int h15_25_min_diff = numeric_limits<unsigned int>::max();
>    unsigned int h35_45_min_diff = numeric_limits<unsigned int>::max();
>    for (map<unsigned int, unsigned int>::const_iterator h25_itr = h2.begin(), end = h2.end(); h25_itr != end; ++h25_itr)
>    {
>       map<unsigned int, unsigned int>::const_iterator h15_itr = h1.find(h25_itr->first);
>       map<unsigned int, unsigned int>::const_iterator h35_itr = h3.find(h25_itr->first);
>       map<unsigned int, unsigned int>::const_iterator h45_itr = h4.find(h25_itr->first);
> 
>       unsigned int h15_25_diff = h15_itr->second > h25_itr->second ?
>                                  h15_itr->second - h25_itr->second :
>                                  h25_itr->second - h15_itr->second;
>       unsigned int h35_45_diff = h35_itr->second > h45_itr->second ?
>                                  h35_itr->second - h45_itr->second :
>                                  h45_itr->second - h35_itr->second;
> 
>       if (h15_25_diff < h15_25_min_diff ||
>           (h15_25_diff == h15_25_min_diff && h35_45_diff < h35_45_min_diff))
>       {
>          h15_25_min_diff = h15_25_diff;
>          h35_45_min_diff = h35_45_diff;
>          n5 = h25_itr->first;
>       }
>    }
> 
>    // Get the hop_counts from n5
>    get_hop_counts(n5, h5);
> /*
>    cout << "n0: " << n0 << endl;
>    cout << "n1: " << n1 << endl;
>    cout << "n2: " << n2 << endl;
>    cout << "n3: " << n3 << endl;
>    cout << "n4: " << n4 << endl;
>    cout << "n5: " << n5 << endl;
> */
> 
>    // Finally layout the graph in polar co-ordinates using the hop counts from these reference nodes
>    for (item_pk::const_iterator itr = itm_pk.begin(), end = itm_pk.end(); itr != end; ++itr)
>    {
>       float radius = h5[itr->id] * 100;
>       /*
>       float theta = h3[itr->id] != h4[itr->id] ?
>                     atan((float(h1[itr->id]) - float(h2[itr->id])) / (float(h3[itr->id]) - float(h4[itr->id]))) :
>                        h1[itr->id] > h2[itr->id] ?  
>                        M_PI / 2 :
>                        -M_PI / 2;
>       */
>       float theta = atan2((float(h1[itr->id]) - float(h2[itr->id])), (float(h3[itr->id]) - float(h4[itr->id])));
>       vertex_locations.insert(make_pair(itr->id, point(radius * cos(theta), radius * sin(theta))));
>    }
> }
> 
> void cpmds::get_graph_straight_line_drawing(map<unsigned int, point> &vertex_locations)
2266,2267c2693,2694
<       unsigned int first_itm_id = f_outer_itr->second_itm_id;
<       unsigned int second_itm_id = f_outer_itr->first_itm_id;
---
>       unsigned int first_itm_id = f_outer_itr->first_itm_id;
>       unsigned int second_itm_id = f_outer_itr->second_itm_id;
2291c2718,2719
<            property<vertex_index_t, unsigned int>
---
>            property<vertex_index_t, unsigned int>,
>            property<edge_index_t, unsigned int>
2294,2300d2721
<       // Define the storage type for the planar embedding
<       typedef vector<vector<graph_traits<graph>::edge_descriptor> > embedding_storage_t;
<       typedef iterator_property_map
<          < embedding_storage_t::iterator, 
<           property_map<graph, vertex_index_t>::type 
<          > embedding_t;
< 
2306c2727
<       //   cout << "Adjacencies:" << endl;
---
>       //cout << "Adjacencies:" << endl;
2309c2730
<          // cout << itr->first_itm_id << ", " << itr->second_itm_id << ", " << itr->third_itm_id << endl;
---
>          //cout << itr->first_itm_id << ", " << itr->second_itm_id << ", " << itr->third_itm_id << endl;
2318,2354c2739,2755
<       /*
<          cout << "Edges:" << endl;
<          graph_traits<graph>::edge_iterator ei, ei_end;
<          for(tie(ei,ei_end) = edges(g); ei != ei_end; ++ei)
<          {
<             cout << *ei << endl;
<          }
<       */
< 
<       // Create the planar embedding
<       embedding_storage_t embedding_storage(num_vertices(g));
<       embedding_t embedding(embedding_storage.begin(), get(vertex_index, g));
< 
<       graph_traits<graph>::vertex_iterator vi, vi_end;
<       for(tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
<       {
<          unsigned int v_index = get(get(vertex_index, g), *vi);
<          unsigned int id = index_to_id[v_index];
< 
<          vector<unsigned int> perimeter;
<          get_perimeter(id, perimeter);
< 
<          vector<graph_traits<graph>::edge_descriptor> vertex_edges;
< 
<          embedding_storage_t embedding_storage;
<          for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
<          {
<             if (*itr != 0)
<             {
<                vertex_edges.push_back(edge(vertex(v_index, g),
<                                            vertex(id_to_index[*itr], g), g).first);
<             }
<          }
< 
<          embedding_storage.push_back(vertex_edges);
<          put(embedding, v_index, embedding_storage.back());
<       }
---
>       // Initialize the interior edge index
>       property_map<graph, edge_index_t>::type e_index = get(edge_index, g);
>       graph_traits<graph>::edges_size_type edge_count = 0;
>       graph_traits<graph>::edge_iterator ei, ei_end;
>       for(tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
>          put(e_index, *ei, edge_count++);
> 
>       //Test for planarity; compute the planar embedding as a side-effect
>       typedef list< graph_traits<graph>::edge_descriptor > vec_t;
>       vector<vec_t> embedding(num_vertices(g));
>       if (!boyer_myrvold_planarity_test(boyer_myrvold_params::graph = g,
>                                        boyer_myrvold_params::embedding = 
>                                        &embedding[0]))
>          cout << "Input graph is not planar" << endl;
>   
>       // Should already be bi-connected, but it can't hurt to be sure
>       make_biconnected_planar(g, &embedding[0]);
2355a2757,2781
>       // Re-initialize the edge index, since we just added a few edges
>       edge_count = 0;
>       for(tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
>          put(e_index, *ei, edge_count++);
> 
>       //Test for planarity again; compute the planar embedding as a side-effect
>       if (!boyer_myrvold_planarity_test(boyer_myrvold_params::graph = g,
>                                         boyer_myrvold_params::embedding = 
>                                        &embedding[0]))
>          cout << "After calling make_biconnected, the graph is not planar" << endl;
> 
>       make_maximal_planar(g, &embedding[0]);
> 
>       // Re-initialize the edge index, since we just added a few edges
>       edge_count = 0;
>       for(tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
>          put(e_index, *ei, edge_count++);
> 
>       // Test for planarity one final time; compute the planar embedding as a 
>       // side-effect
>       if (!boyer_myrvold_planarity_test(boyer_myrvold_params::graph = g,
>                                         boyer_myrvold_params::embedding = 
>                                         &embedding[0]))
>          cout << "After calling make_maximal_planar, the graph is not planar." << endl;
>   
2357,2358c2783,2784
<       vector<graph_traits<graph>::vertex_descriptor> ordering;
<       patched_planar_canonical_ordering(g, embedding, back_inserter(ordering));
---
>       list<graph_traits<graph>::vertex_descriptor> ordering;
>       planar_canonical_ordering(g, &embedding[0], back_inserter(ordering));
2371,2383d2796
<             cout << "Embedding:" << endl;
<             for(tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
<             {
<                unsigned int v_index = get(get(vertex_index, g), *vi);
< 
<                cout << "(" << v_index << ") " << index_to_id[v_index] << " : ";
<                for (embedding_storage_t::value_type::const_iterator ei = get(embedding, v_index).begin(), ei_end = get(embedding, v_index).end(); ei != ei_end; ++ei)
<                {
<                   unsigned int target_index = get(get(vertex_index, g), target(*ei, g));
<                   cout << " " << index_to_id[target_index];
<                }
<                cout << endl;
<             }
2411a2825
>       graph_traits<graph>::vertex_iterator vi, vi_end;
2491a2906
>    _flattened_boundary_items.clear();
2501c2916
<    vector<pair<double, double> > sub_measures;
---
>    list<pair<double, double> > sub_measures;
2511c2926
<       for (vector<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
---
>       for (list<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
2521c2936
<       for (vector<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
---
>       for (list<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
2533c2948
<       for (vector<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
---
>       for (list<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
2548c2963
<    vector<unsigned int> perimeter;
---
>    list<unsigned int> perimeter;
2554,2555c2969,2970
<    vector<pair<double, double> > sub_measures;
<    for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>    list<pair<double, double> > sub_measures;
>    for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
2563c2978
<       for (vector<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
---
>       for (list<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
2573c2988
<       for (vector<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
---
>       for (list<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
2585c3000
<       for (vector<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
---
>       for (list<pair<double, double> >::const_iterator itr = sub_measures.begin(), end = sub_measures.end(); itr != end; ++itr)
2610c3025
<          for (; rel_itr != rel_end_itr; ++rel_itr)
---
>          for (; rel_itr != rel_end_itr && rel_itr->second_itm_id != second_itm_id; ++rel_itr)
2612d3026
<             if (rel_itr->second_itm_id == second_itm_id) break;
2616c3030,3031
<          weighted_measure.first = 1.; 
---
>          if (rel_itr == rel_end_itr) weighted_measure.first = 0;
>          else weighted_measure.first = 1.; 
2695,2697d3109
<       remove_item(id, adjustments, false);
<       insert_item(id, f_nearest_itr, adjustments, false);
< 
2699,2700c3111
<       const item_pk& itm_pk = item_table.get<item_pk_type>();
<       for (map<unsigned int, item_adjustment>::const_iterator itr = adjustments.begin(), end = adjustments.end(); itr != end; ++itr)
---
>       if (_focus == 0)
2702,2704c3113,3123
<          item_pk::const_iterator itm_itr = itm_pk.find(itr->first);
<          stress_delta += (itr->second.distance_weight_sum_delta - itr->second.weight_sum_delta * itm_itr->distance_weight_sum / itm_itr->weight_sum)
<                          / (itm_itr->weight_sum + itr->second.weight_sum_delta);
---
>          remove_item(id, adjustments, false);
>          insert_item(id, f_nearest_itr, adjustments, false);
> 
>          const item_pk& itm_pk = item_table.get<item_pk_type>();
>          for (map<unsigned int, item_adjustment>::const_iterator itr = adjustments.begin(), end = adjustments.end(); itr != end; ++itr)
>          {
>             item_pk::const_iterator itm_itr = itm_pk.find(itr->first);
>             stress_delta += (itr->second.distance_weight_sum_delta - itr->second.weight_sum_delta * itm_itr->distance_weight_sum / itm_itr->weight_sum)
>                             / (itm_itr->weight_sum + itr->second.weight_sum_delta);
>          }
>          stress_delta /= item_table.size();
2706d3124
<       stress_delta /= item_table.size();
2708c3126
<       if (stress_delta < 0)
---
>       if (stress_delta <= 0)
2712c3130,3140
<             if (!is_channel_item(id)) move_item = true;
---
>             adjacency_face_third_itm_idx& adf_third_itm_idx = adjacency_face_table.get<adjacency_face_third_itm_idx_type>();
>             adjacency_face_third_itm_idx::const_iterator f_outer_itr, f_outer_end_itr;
>             tie(f_outer_itr, f_outer_end_itr) = adf_third_itm_idx.equal_range(boost::make_tuple(0)); 
> 
>             // There must be at least three exterior items to ensure planarity
>             // Also ensure we didn't previously convert his item to an exterior item
>             if (distance(f_outer_itr, f_outer_end_itr) > 3 &&
>                 !is_separating_item(id))
>             {
>                move_item = true;
>             }
2730,2731c3158,3159
< // A channel vertex is one that if remove will produce two graphs connected by a single vertex
< bool cpmds::is_channel_item(unsigned int id) const
---
> // A separating vertex is one that if remove will produce two graphs connected by a single vertex
> bool cpmds::is_separating_item(unsigned int id) const
2733,2734c3161,3162
<    bool is_channel = false;
<    vector<unsigned int> perimeter;
---
>    bool is_separating = false;
>    list<unsigned int> perimeter;
2740c3168
<    for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>    for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
2761c3189
<    if (broken_perimeter_count > 2) is_channel = true;
---
>    if (broken_perimeter_count > 2) is_separating = true;
2764,2765c3192,3193
<    if (get_connectivity(perimeter.back()) == 2) is_channel = true;
<    if (get_connectivity(*(++perimeter.begin())) == 2) is_channel = true;
---
>    if (get_connectivity(perimeter.back()) == 2) is_separating = true;
>    if (get_connectivity(*(++perimeter.begin())) == 2) is_separating = true;
2767c3195
<    return is_channel;
---
>    return is_separating;
2773c3201
<    vector<unsigned int> perimeter;
---
>    list<unsigned int> perimeter;
2825c3253
<    vector<unsigned int> perimeter;
---
>    list<unsigned int> perimeter;
2832c3260
<    for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>    for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
2834c3262
<       vector<unsigned int>::const_iterator next_itr = itr;
---
>       list<unsigned int>::const_iterator next_itr = itr;
2837c3265,3266
<       if (*itr != 0 && *next_itr != 0)
---
> 
>       if (*itr != 0)
2840d3268
<          item_pk::const_iterator itm_b_itr = itm_pk.find(*next_itr);
2841a3270,3285
> 
>          if (*next_itr != 0)
>          {
>             item_pk::const_iterator itm_b_itr = itm_pk.find(*next_itr);
>             double r_b = itm_b_itr->radius;
> 
>             curvature -= subtended_angle(r, r_a, r_b);
>          }
>          else
>          {
>             curvature -= subtended_half_angle(r, r_a);
>          }
>       }
>       else if (*next_itr != 0)
>       {
>          item_pk::const_iterator itm_b_itr = itm_pk.find(*next_itr);
2843c3287
<          curvature -= subtended_angle(r, r_a, r_b);
---
>          curvature -= subtended_half_angle(r, r_b);
2861c3305
<    vector<unsigned int> perimeter;
---
>    list<unsigned int> perimeter;
2870c3314
<    for (vector<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
---
>    for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
2901c3345
< bool cpmds::is_beneficial_adjustment(unsigned int id, double curvature_adjustment)
---
> bool cpmds::is_beneficial_adjustment(unsigned int id, double curvature_adjustment) const
2931a3376,3417
> // Calculate the hop counts from a vertex
> void cpmds::get_hop_counts(unsigned int id, map<unsigned int, unsigned int> &hop_counts)
> {
>    set<unsigned int> processed_vertices;
>    
>    queue<unsigned int> unprocessed_vertices;
> 
>    hop_counts[id] = 0;
>    unprocessed_vertices.push(id);
> 
>    while (!unprocessed_vertices.empty())   
>    {
>       unsigned int current_id = unprocessed_vertices.front();
>       unprocessed_vertices.pop();
> 
>       if (processed_vertices.find(current_id) == processed_vertices.end())
>       {
>          list<unsigned int> perimeter;
>          get_perimeter(current_id, perimeter);  
> 
>          unsigned int current_hop_count = hop_counts[current_id];
> 
>          for (list<unsigned int>::const_iterator itr = perimeter.begin(), end = perimeter.end(); itr != end; ++itr)
>          {
>             if (*itr != 0 && hop_counts.find(*itr) == hop_counts.end())
>             {
>                hop_counts[*itr] = current_hop_count + 1;
>                unprocessed_vertices.push(*itr);
>             }
>          }
> 
>          processed_vertices.insert(current_id);
>       }
>    }
> }
> 
> 
> 
> 
> 
> 
> 
